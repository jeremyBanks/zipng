#![allow(clippy::unusual_byte_groupings)]

use {
    crate::{
        checksums::{adler32, crc32},
        generic::panic,
    },
    bitvec::vec::BitVec,
    std::ops::{Not, Range},
    tracing::warn,
};

pub use self::{BitDepth::*, ColorType::*};

/// In-memory representation of a PNG file's essential image contents.
#[derive(Debug, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Default)]
#[non_exhaustive]
pub struct Png {
    pub width: u32,
    pub height: u32,
    pub bit_depth: BitDepth,
    pub color_type: ColorType,
    pub pixel_data: Vec<u8>,
    pub palette_data: Option<Vec<u8>>,
    pub transparency_data: Option<Vec<u8>>,
}

impl Png {
    pub fn to_bytes(&self) -> Vec<u8> {
        todo!()
    }

    pub fn from_bytes(bytes: &[u8]) -> Result<Self, panic> {
        todo!()
    }

    /// Sets the pixel at the given coordinates to the given color.
    /// The required length of the color data may vary depending on the
    /// color type and bit depth of the image.
    pub fn set_pixel(&mut self, x: u32, y: u32, color: &[u8]) -> Result<(), ()> {
        todo!()
    }
}

/// The bit depth of an image, as defined in the PNG specification.
///
/// > **bit depth**: for indexed-colour images, the number of bits per palette
/// > index. For other images, the number of bits per sample in the image. This
/// > is the value that appears in the `IHDR` Image header chunk.
///
/// > **sample**: intersection of a channel and a pixel in an image.
///
/// > **channel**: array of all per-pixel information of a particular kind
/// > within a reference image. There are five kinds of information: red, green,
/// > blue, greyscale, and alpha.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(u8)]
pub enum BitDepth {
    One = 1,
    Two = 2,
    Four = 4,
    #[default]
    Eight = 8,
    Sixteen = 16,
}

/// The color type of an image, as defined in the PNG specification.
///
/// > There are five types of PNG image. Corresponding to each type is a
/// > **colour type**, which is the sum of the following values: 1 (palette
/// > used), 2 (truecolour used) and 4 (alpha used). Greyscale and truecolour
/// > images may have an explicit alpha channel. The PNG image types and
/// > corresponding colour types are listed in Table 8.
///
/// > **greyscale**: image representation in which each pixel is defined by a
/// > single sample of colour information, representing overall luminance (on a
/// > scale from black to white)
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(u8)]
pub enum ColorType {
    #[default]
    Luminance = 0,
    RedGreenBlue = 2,
    Indexed = 3,
    LuminanceAlpha = 4,
    RedGreenBlueAlpha = 6,
}

impl BitDepth {
    pub fn bits_per_sample(&self) -> usize {
        u8::from(*self).into()
    }
}

impl From<BitDepth> for u8 {
    fn from(depth: BitDepth) -> Self {
        depth as u8
    }
}

impl ColorType {
    pub fn samples_per_pixel(&self) -> usize {
        match self {
            Luminance => 1,
            RedGreenBlue => 3,
            Indexed => 1,
            LuminanceAlpha => 2,
            RedGreenBlueAlpha => 4,
        }
    }
}

impl From<ColorType> for u8 {
    fn from(val: ColorType) -> Self {
        val as u8
    }
}

pub fn write_png_header(
    buffer: &mut Vec<u8>,
    width: u32,
    height: u32,
    color_depth: BitDepth,
    color_mode: ColorType,
) -> Range<usize> {
    let before = buffer.len();

    buffer.extend_from_slice(b"\x89PNG\r\n\x1A\n");
    write_png_chunk(buffer, b"IHDR", &{
        let mut data = Vec::new();
        // pixel width
        data.extend_from_slice(&u32::from(width).to_be_bytes());
        // pixel height
        data.extend_from_slice(&u32::from(height).to_be_bytes());
        // color bit depth
        data.extend_from_slice(&u8::from(color_depth).to_be_bytes());
        // color type: grayscale
        data.extend_from_slice(&u8::from(color_mode).to_be_bytes());
        // compression method: deflate
        data.extend_from_slice(&u8::from(0_u8).to_be_bytes());
        // filter method: basic
        data.extend_from_slice(&u8::from(0_u8).to_be_bytes());
        // interlace method: none
        data.extend_from_slice(&u8::from(0_u8).to_be_bytes());

        data
    });

    let after = buffer.len();
    before..after
}

pub fn write_png_palette(buffer: &mut Vec<u8>, palette: &[u8]) -> Range<usize> {
    write_png_chunk(buffer, b"PLTE", palette)
}

pub fn write_png_body(buffer: &mut Vec<u8>, data: &[u8]) -> Range<usize> {
    let mut deflated = Vec::new();
    write_non_deflated(&mut deflated, data);
    write_png_chunk(buffer, b"IDAT", &deflated)
}

pub fn write_non_deflated(buffer: &mut Vec<u8>, data: &[u8]) -> Range<usize> {
    let chunks = data.chunks(0xFFFF);

    // zlib compression mode: deflate with 32KiB windows
    let cmf = 0b_0111_1000;
    buffer.push(cmf);
    // zlib flag bits: no preset dictionary, compression level 0
    let mut flg: u8 = 0b_00_0_00000;
    // zlib flag and check bits
    flg |= 0b_11111 - ((((cmf as u16) << 8) | (flg as u16)) % 0b_11111) as u8;
    buffer.push(flg);

    let mut before = None;
    let mut after = None;

    let count = chunks.len();
    for (index, chunk) in chunks.enumerate() {
        // deflate flag bits
        let is_last_chunk = index + 1 >= count;
        buffer.push(is_last_chunk.into());
        // deflate block length
        buffer.extend_from_slice(&u16::try_from(chunk.len()).unwrap().to_le_bytes());
        // deflate block length check complement
        buffer.extend_from_slice(&u16::try_from(chunk.len()).unwrap().not().to_le_bytes());

        // Is there any way I can massage this into looking like a PNG
        // filter prefix? We can't get rid of the lengths, and they're constant, but I
        // guess we can accept that as a border. hmm... if at least one of their
        // bytes is zero (yes), it will be possible to treat the middle byte as the
        // filter and have the border on both sides.

        before.get_or_insert(buffer.len());
        buffer.extend_from_slice(chunk);
        after = Some(buffer.len());
    }

    // adler-32 checksum of the uncompressed data
    buffer.extend_from_slice(&adler32(data).to_le_bytes());

    let after = after.unwrap_or(buffer.len());
    let before = before.unwrap_or(after);

    before..after
}

pub fn write_non_png_chunk(buffer: &mut Vec<u8>, data: &[u8]) -> Range<usize> {
    write_png_chunk(buffer, b"pkPK", data)
}

pub fn write_png_footer(buffer: &mut Vec<u8>) -> Range<usize> {
    write_png_chunk(buffer, b"IEND", b"")
}

pub fn write_png_chunk(buffer: &mut Vec<u8>, chunk_type: &[u8; 4], data: &[u8]) -> Range<usize> {
    let before = buffer.len();

    buffer.extend_from_slice(
        &u32::try_from(data.len())
            .expect("png chunk larger than 2GiB")
            .to_be_bytes(),
    );
    buffer.extend_from_slice(chunk_type);
    buffer.extend_from_slice(data);
    buffer.extend_from_slice(
        &crc32(
            &[chunk_type.as_slice(), data]
                .into_iter()
                .flatten()
                .copied()
                .collect::<Vec<_>>(),
        )
        .to_be_bytes(),
    );

    let after = buffer.len();
    before..after
}

pub fn write_png(
    buffer: &mut Vec<u8>,
    data: &[u8],
    width: u32,
    height: u32,
    bit_depth: BitDepth,
    color_mode: ColorType,
    palette: Option<&[u8]>,
) {
    write_png_header(buffer, width, height, bit_depth, color_mode);
    if let Some(palette) = palette {
        write_png_palette(buffer, palette);
    }
    // We need to insert a 0x00 byte at the start of every line (every `width`
    // bytes) to indicate that the line is not filtered.
    let mut filtered_data = Vec::new();

    let bits_per_pixel = bit_depth.bits_per_sample() * color_mode.samples_per_pixel();
    let bits_per_line = width * bits_per_pixel as u32;
    let bytes_per_line = (bits_per_line + 7) / 8;

    for (i, byte) in data.iter().enumerate() {
        if i % (bytes_per_line as usize) == 0 {
            filtered_data.push(0x00);
        }
        filtered_data.push(*byte);
    }
    write_png_body(buffer, &filtered_data);
    write_png_footer(buffer);
}

pub fn default_for_data(data: &[u8]) {

    // opts.bit_depth = EightBit;
    // opts.color_mode = Indexed;
    // opts.color_palette = Some(PALLETTE_8_BIT_DATA.to_vec());
    // opts.max_height = 8192;

    // match data.len() {
    //     len @ 0x0..=0x20 => {
    //         opts.color_palette = None;
    //         opts.bit_depth = OneBit;
    //         opts.color_mode = Luminance;
    //         opts.width = 16.min(len * 8);
    //     },
    //     0x21..=0x100 => {
    //         opts.color_palette = None;
    //         opts.bit_depth = TwoBit;
    //         opts.color_mode = Luminance;
    //         opts.width = 16;
    //     },
    //     0x101..=0x200 => {
    //         opts.width = 16;
    //     },
    //     0x201..=0x800 => {
    //         opts.width = 32;
    //     },
    //     0x801..=0x2000 => {
    //         opts.width = 64;
    //     },
    //     0x2001..=0x8000 => {
    //         opts.width = 128;
    //     },
    //     0x8001..=0x20000 => {
    //         opts.width = 256;
    //     },
    //     0x20001..=0x80000 => {
    //         opts.width = 512;
    //     },
    //     0x80001..=0x200000 => {
    //         opts.width = 1024;
    //     },
    //     0x200001..=0x800000 => {
    //         opts.width = 1024;
    //         opts.color_palette = None;
    //         opts.color_mode = RedGreenBlue;
    //     },
    //     len => {
    //         opts.width = 1024;
    //         opts.color_palette = None;
    //         opts.color_mode = RedGreenBlueAlpha;
    //         warn!("zip data size is too damn high ({len} bytes)");
    //     },
    // }
}

pub const PALLETTE_8_BIT_DATA: &[u8; 256 * 3] = &[
    0x00, 0x00, 0x00, 0x01, 0x80, 0x20, 0x02, 0x80, 0x20, 0x03, 0x80, 0x20, 0x04, 0x80, 0x20, 0x05,
    0x80, 0x20, 0x06, 0x80, 0x20, 0x07, 0x80, 0x20, 0x08, 0x80, 0x20, 0x09, 0x09, 0x09, 0x0A, 0x0A,
    0x0A, 0x0B, 0x80, 0x20, 0x0C, 0x80, 0x20, 0x0D, 0x0D, 0x0D, 0x0E, 0x80, 0x20, 0x0F, 0x80, 0x20,
    0x10, 0x80, 0x20, 0x11, 0x80, 0x20, 0x12, 0x80, 0x20, 0x13, 0x80, 0x20, 0x14, 0x80, 0x20, 0x15,
    0x80, 0x20, 0x16, 0x80, 0x20, 0x17, 0x80, 0x20, 0x18, 0x80, 0x20, 0x19, 0x80, 0x20, 0x1A, 0x80,
    0x20, 0x1B, 0x80, 0x20, 0x1C, 0x80, 0x20, 0x1D, 0x80, 0x20, 0x1E, 0x80, 0x20, 0x1F, 0x80, 0x20,
    0x20, 0x20, 0x20, 0x21, 0xFF, 0x80, 0x22, 0xFF, 0x80, 0x23, 0xFF, 0x80, 0x24, 0xFF, 0x80, 0x25,
    0xFF, 0x80, 0x26, 0xFF, 0x80, 0x27, 0xFF, 0x80, 0x28, 0xFF, 0x80, 0x29, 0xFF, 0x80, 0x2A, 0xFF,
    0x80, 0x2B, 0xFF, 0x80, 0x2C, 0xFF, 0x80, 0x2D, 0xFF, 0x80, 0x2E, 0xFF, 0x80, 0x2F, 0xFF, 0x80,
    0x30, 0xFF, 0x80, 0x31, 0xFF, 0x80, 0x32, 0xFF, 0x80, 0x33, 0xFF, 0x80, 0x34, 0xFF, 0x80, 0x35,
    0xFF, 0x80, 0x36, 0xFF, 0x80, 0x37, 0xFF, 0x80, 0x38, 0xFF, 0x80, 0x39, 0xFF, 0x80, 0x3A, 0xFF,
    0x80, 0x3B, 0xFF, 0x80, 0x3C, 0xFF, 0x80, 0x3D, 0xFF, 0x80, 0x3E, 0xFF, 0x80, 0x3F, 0xFF, 0x80,
    0x40, 0xFF, 0x80, 0x41, 0xFF, 0x80, 0x42, 0xFF, 0x80, 0x43, 0xFF, 0x80, 0x44, 0xFF, 0x80, 0x45,
    0xFF, 0x80, 0x46, 0xFF, 0x80, 0x47, 0xFF, 0x80, 0x48, 0xFF, 0x80, 0x49, 0xFF, 0x80, 0x4A, 0xFF,
    0x80, 0x4B, 0xFF, 0x80, 0x4C, 0xFF, 0x80, 0x4D, 0xFF, 0x80, 0x4E, 0xFF, 0x80, 0x4F, 0xFF, 0x80,
    0x50, 0xFF, 0x80, 0x51, 0xFF, 0x80, 0x52, 0xFF, 0x80, 0x53, 0xFF, 0x80, 0x54, 0xFF, 0x80, 0x55,
    0xFF, 0x80, 0x56, 0xFF, 0x80, 0x57, 0xFF, 0x80, 0x58, 0xFF, 0x80, 0x59, 0xFF, 0x80, 0x5A, 0xFF,
    0x80, 0x5B, 0xFF, 0x80, 0x5C, 0xFF, 0x80, 0x5D, 0xFF, 0x80, 0x5E, 0xFF, 0x80, 0x5F, 0xFF, 0x80,
    0x60, 0xFF, 0x80, 0x61, 0xFF, 0x80, 0x62, 0xFF, 0x80, 0x63, 0xFF, 0x80, 0x64, 0xFF, 0x80, 0x65,
    0xFF, 0x80, 0x66, 0xFF, 0x80, 0x67, 0xFF, 0x80, 0x68, 0xFF, 0x80, 0x69, 0xFF, 0x80, 0x6A, 0xFF,
    0x80, 0x6B, 0xFF, 0x80, 0x6C, 0xFF, 0x80, 0x6D, 0xFF, 0x80, 0x6E, 0xFF, 0x80, 0x6F, 0xFF, 0x80,
    0x70, 0xFF, 0x80, 0x71, 0xFF, 0x80, 0x72, 0xFF, 0x80, 0x73, 0xFF, 0x80, 0x74, 0xFF, 0x80, 0x75,
    0xFF, 0x80, 0x76, 0xFF, 0x80, 0x77, 0xFF, 0x80, 0x78, 0xFF, 0x80, 0x79, 0xFF, 0x80, 0x7A, 0xFF,
    0x80, 0x7B, 0xFF, 0x80, 0x7C, 0xFF, 0x80, 0x7D, 0xFF, 0x80, 0x7E, 0xFF, 0x80, 0x7F, 0x80, 0x20,
    0x80, 0x40, 0x80, 0x81, 0x40, 0x80, 0x82, 0x40, 0x80, 0x83, 0x40, 0x80, 0x84, 0x40, 0x80, 0x85,
    0x40, 0x80, 0x86, 0x40, 0x80, 0x87, 0x40, 0x80, 0x88, 0x40, 0x80, 0x89, 0x40, 0x80, 0x8A, 0x40,
    0x80, 0x8B, 0x40, 0x80, 0x8C, 0x40, 0x80, 0x8D, 0x40, 0x80, 0x8E, 0x40, 0x80, 0x8F, 0x40, 0x80,
    0x90, 0x40, 0x80, 0x91, 0x40, 0x80, 0x92, 0x40, 0x80, 0x93, 0x40, 0x80, 0x94, 0x40, 0x80, 0x95,
    0x40, 0x80, 0x96, 0x40, 0x80, 0x97, 0x40, 0x80, 0x98, 0x40, 0x80, 0x99, 0x40, 0x80, 0x9A, 0x40,
    0x80, 0x9B, 0x40, 0x80, 0x9C, 0x40, 0x80, 0x9D, 0x40, 0x80, 0x9E, 0x40, 0x80, 0x9F, 0x40, 0x80,
    0xA0, 0x40, 0x80, 0xA1, 0x40, 0x80, 0xA2, 0x40, 0x80, 0xA3, 0x40, 0x80, 0xA4, 0x40, 0x80, 0xA5,
    0x40, 0x80, 0xA6, 0x40, 0x80, 0xA7, 0x40, 0x80, 0xA8, 0x40, 0x80, 0xA9, 0x40, 0x80, 0xAA, 0x40,
    0x80, 0xAB, 0x40, 0x80, 0xAC, 0x40, 0x80, 0xAD, 0x40, 0x80, 0xAE, 0x40, 0x80, 0xAF, 0x40, 0x80,
    0xB0, 0x40, 0x80, 0xB1, 0x40, 0x80, 0xB2, 0x40, 0x80, 0xB3, 0x40, 0x80, 0xB4, 0x40, 0x80, 0xB5,
    0x40, 0x80, 0xB6, 0x40, 0x80, 0xB7, 0x40, 0x80, 0xB8, 0x40, 0x80, 0xB9, 0x40, 0x80, 0xBA, 0x40,
    0x80, 0xBB, 0x40, 0x80, 0xBC, 0x40, 0x80, 0xBD, 0x40, 0x80, 0xBE, 0x40, 0x80, 0xBF, 0x40, 0x80,
    0xC0, 0x40, 0x80, 0xC1, 0x40, 0x80, 0xC2, 0x40, 0x80, 0xC3, 0x40, 0x80, 0xC4, 0x40, 0x80, 0xC5,
    0x40, 0x80, 0xC6, 0x40, 0x80, 0xC7, 0x40, 0x80, 0xC8, 0x40, 0x80, 0xC9, 0x40, 0x80, 0xCA, 0x40,
    0x80, 0xCB, 0x40, 0x80, 0xCC, 0x40, 0x80, 0xCD, 0x40, 0x80, 0xCE, 0x40, 0x80, 0xCF, 0x40, 0x80,
    0xD0, 0x40, 0x80, 0xD1, 0x40, 0x80, 0xD2, 0x40, 0x80, 0xD3, 0x40, 0x80, 0xD4, 0x40, 0x80, 0xD5,
    0x40, 0x80, 0xD6, 0x40, 0x80, 0xD7, 0x40, 0x80, 0xD8, 0x40, 0x80, 0xD9, 0x40, 0x80, 0xDA, 0x40,
    0x80, 0xDB, 0x40, 0x80, 0xDC, 0x40, 0x80, 0xDD, 0x40, 0x80, 0xDE, 0x40, 0x80, 0xDF, 0x40, 0x80,
    0xE0, 0x40, 0x80, 0xE1, 0x40, 0x80, 0xE2, 0x40, 0x80, 0xE3, 0x40, 0x80, 0xE4, 0x40, 0x80, 0xE5,
    0x40, 0x80, 0xE6, 0x40, 0x80, 0xE7, 0x40, 0x80, 0xE8, 0x40, 0x80, 0xE9, 0x40, 0x80, 0xEA, 0x40,
    0x80, 0xEB, 0x40, 0x80, 0xEC, 0x40, 0x80, 0xED, 0x40, 0x80, 0xEE, 0x40, 0x80, 0xEF, 0x40, 0x80,
    0xF0, 0x40, 0x80, 0xF1, 0x40, 0x80, 0xF2, 0x40, 0x80, 0xF3, 0x40, 0x80, 0xF4, 0x40, 0x80, 0xF5,
    0x40, 0x80, 0xF6, 0x40, 0x80, 0xF7, 0x40, 0x80, 0xF8, 0x40, 0x80, 0xF9, 0x40, 0x80, 0xFA, 0x40,
    0x80, 0xFB, 0x40, 0x80, 0xFC, 0x40, 0x80, 0xFD, 0x40, 0x80, 0xFE, 0x40, 0x80, 0xFF, 0x40, 0x80,
];

pub const BIT_DENSITY_MAP: &[u8; 256] = &[
    0x00, 0x02, 0x80, 0x40, 0x04, 0x20, 0x10, 0x01, 0x08, 0x82, 0x44, 0x30, 0x09, 0x42, 0x84, 0x21,
    0x18, 0x06, 0xC0, 0x11, 0x28, 0x03, 0x14, 0x60, 0x88, 0x05, 0x12, 0x48, 0xA0, 0x41, 0x0C, 0x22,
    0x90, 0x0A, 0x24, 0x50, 0x81, 0x0E, 0x70, 0x89, 0x26, 0x51, 0x8A, 0x34, 0xC1, 0x2A, 0x54, 0x83,
    0x2C, 0xD0, 0x0B, 0x64, 0x91, 0x4A, 0xA4, 0x13, 0x4C, 0xB0, 0x43, 0x8C, 0x31, 0x46, 0xA8, 0x15,
    0xC2, 0x38, 0x07, 0xC8, 0x32, 0x45, 0x98, 0x23, 0xC4, 0x1A, 0x25, 0x58, 0xA2, 0x0D, 0x52, 0xA1,
    0x1C, 0x62, 0x85, 0x68, 0x92, 0x49, 0x16, 0xE0, 0x19, 0x86, 0x61, 0x94, 0x29, 0x56, 0xA9, 0xD2,
    0x2D, 0xC6, 0x39, 0x96, 0x69, 0xD4, 0x2B, 0x95, 0x6A, 0x9C, 0x63, 0xB4, 0x4B, 0x3C, 0xC3, 0xAC,
    0x53, 0xB8, 0x47, 0xAA, 0x55, 0xE8, 0x17, 0xCA, 0x35, 0xE2, 0x1D, 0xF0, 0x0F, 0xE1, 0x1E, 0xE4,
    0x1B, 0xC5, 0x3A, 0x65, 0x9A, 0xA5, 0x5A, 0x27, 0xD8, 0x87, 0x78, 0xA3, 0x5C, 0xA6, 0x59, 0xB2,
    0x4D, 0x36, 0xC9, 0x33, 0xCC, 0x72, 0x8D, 0x71, 0x8E, 0x74, 0x8B, 0x66, 0x99, 0x6C, 0x93, 0x2E,
    0xD1, 0x4E, 0xB1, 0x6E, 0x9D, 0x73, 0xCE, 0xB5, 0x6B, 0x9E, 0xF1, 0x4F, 0xBC, 0xE3, 0x5E, 0xB9,
    0x67, 0xDC, 0xB3, 0x6D, 0xDA, 0xA7, 0x5D, 0xBA, 0xE5, 0x5B, 0xB6, 0xCD, 0x7A, 0x97, 0xE9, 0x3E,
    0xC7, 0x79, 0xAE, 0xD5, 0x3B, 0xE6, 0xD9, 0x2F, 0xD6, 0x3D, 0xEA, 0x57, 0xAD, 0xF2, 0x1F, 0xEC,
    0xD3, 0x7C, 0xAB, 0x75, 0x8F, 0xF8, 0x37, 0xCB, 0xF4, 0x9B, 0x76, 0xED, 0x9F, 0x7B, 0xF6, 0xAF,
    0xDD, 0xF3, 0x7E, 0xBD, 0xCF, 0x77, 0xFA, 0xB7, 0x7D, 0xEB, 0xDE, 0xF5, 0x3F, 0xDB, 0xEE, 0xF9,
    0xD7, 0x6F, 0xBE, 0x5F, 0xE7, 0xBB, 0xFC, 0xDF, 0x7F, 0xF7, 0xEF, 0xFB, 0xBF, 0xFD, 0xFE, 0xFF,
];
